{
    "contents" : "# Грузить данные желательно в последние несколько дней месяца\n\n#### LOADING SVNC FACT DATA ####\nrm(list = ls())\n\n# Loading libraries\nlibrary(RJDBC)\nlibrary(rJava)\nlibrary(tsauxfunc)\nlibrary(dplyr)\n\n# setting working directory and loading cached data\nsetwd('C:/!zemskov/svnc_forecast/data_sources/')\nload(\"SVNC_P_V_KOM_FACT.RData\")\nload(\"PIKES_FACT.RData\")\nload(\"VOLUMES_FACT.RData\")\n\n# Set JAVA_HOME, set max. memory, and load rJava library\nSys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_65/bin')\n#options(java.parameters=\"-Xmx2g\")\n\n# Checking Java version\n.jinit()\nprint(.jcall(\"java/lang/System\", \"S\", \"getProperty\", \"java.version\"))\n\n# Create connection driver and open connection\n## ORACLE:\njdbcDriver <- JDBC(driverClass=\"oracle.jdbc.OracleDriver\", \n                   classPath=\"C:/!zemskov/ORALIBS/ojdbc7.jar\")\njdbcConnectionSVNC <- dbConnect(jdbcDriver, \n                  \"jdbc:oracle:thin:@//hx5-06.rosenergo.com:1521/svncgrey.rosenergo.com\", \"zemskov\", \"Lun2i2q\")\n\n# VERTICA:\nverticaDriver <- JDBC(driverClass = \"com.vertica.jdbc.Driver\", \n                      classPath=\"C:/!zemskov/VERTICA_JDBC/vertica-jdbc-7.2.3-0.jar\")\nverticaConnection <- dbConnect(verticaDriver, \n                               \"jdbc:vertica://vertica-red-srv.rosenergo.com:5433/DWH\", \n                               \"zemskov\", \"Lun2i2q\")\n\n# Testing connection with simple query\n#current_date <- dbGetQuery(jdbcConnectionSVNC, \"SELECT current_date FROM dual\")\n\n# Setting up some basic date variables to use queries later\nhistory_begin_date <- \"2011-01-01\"\nbegin_date <- as.Date(cut(max(svnc_p_v_kom$TDATE) + 25, \"month\"))\nend_date <- Sys.Date()\nforecast_date <- as.Date(cut(end_date + 25, \"month\"))\nbegin_year <- cut(max(svnc_p_v_kom$TDATE) + 25, \"year\") # for KOM\nend_year <- cut(forecast_date, \"year\")                  # for KOM\n\n# deleting evaluated and 'not full month data'\nretrieved_volumes <- retrieved_volumes[retrieved_volumes$TDATE \n                                       < as.Date(begin_date), ]\npikes <- pikes[pikes$TDATE < as.Date(begin_date), ]\n\nsvnc_p_v_kom <- svnc_p_v_kom[svnc_p_v_kom$TDATE < as.Date(begin_date), ]\n\n# extract DGPC_GP-info\nextractDPGGP <- function(connection, date) {\n  message(\"extracting DPG_GP info ...\")\n  message(\"starting query ...\")\n  message(\"for \", begin_date)\n  query <- \n    paste(\"\n          select\n            t1.pcode,\n            t1.pname,\n            t1.tcode,\n            t1.pz,\n            t1.region_code,\n            t2.region_name\n          from\n            (select\n    \t\t      p.trader_code as pcode,\n              p.short_name as pname,\n              t.trader_code as tcode,\n              t.price_zone_code as pz,\n              t.region_code \n            from\n              crmdb.trader t,\n              crmdb.trader p\n            where\n              t.parent_object_id = p.trader_id\n              and to_date('\",date,\"','yyyy.mm.dd') between t.begin_date and t.end_date \n              and t.trader_type = 100\n              and nvl(t.is_fsk,0) = 0\n              and t.is_guarantee_supply_co = 1\n              and t.is_unpriced_zone ^= 1\n              and nvl(t.price_zone_code, 0) in (1,2)\n              and (t.is_spot_trader = 1\n                or t.is_forem_trader = 1)\n            order by\n              pcode, region_code) t1\n          left join\n            (select\n              region_code,\n              region_name\n            from\n              crmdb.region) t2\n            on\n              t1.region_code = t2.region_code\n            order by\n              pcode,\n              region_code\n          \")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\njdbcConnectionRIO <- dbConnect(jdbcDriver, \n    \"jdbc:oracle:thin:@//x240-11.rosenergo.com:1521/frs9i2.rosenergo.com\", \n    \"zemskov\", \"Lun2i2q\")\ndpg_gp_info <- extractDPGGP(jdbcConnectionRIO, forecast_date)\nsave(file = 'C:/!zemskov/svnc_forecast/data_sources/DPG_GP_INFO.RData', dpg_gp_info)\nload(file = 'C:/!zemskov/svnc_forecast/data_sources/DPG_GP_INFO.RData')\ngp_region <- unique(select(dpg_gp_info, PCODE, REGION_CODE, REGION_NAME))\ndbDisconnect(jdbcConnectionRIO)\n\n# extract data with fact prices by dpg\nextractSVNC_FACT <- function(connection, begin_date, end_date, ...) {\n  message(\"extracting SVNC ...\")\n  message(\"starting query ...\")\n  message(\"from \", begin_date, \" to \", end_date)\n  query <- \n    paste(\"\n          select \n            t1.*, \n            reg.region_name\n          from(\n          with table_period as\n          (\n            select s.begin_date, max(s.session_id) as session_id, s.final_calculation_flag\n            from \n          (\n            select \n              begin_date, \n              max(final_calculation_flag) as final_calculation_flag\n            from \n              rep_nov.frs_pr_session\n            where\n              begin_date between to_date('\",begin_date,\"', 'yyyy-mm-dd') \n              and to_date('\",end_date,\"','yyyy-mm-dd')\n            group by \n              begin_date\n          ) ts,\n            rep_nov.frs_pr_session s\n          where \n            ts.begin_date = s.begin_date \n            and ts.final_calculation_flag = s.final_calculation_flag\n          group by\n            s.begin_date, s.final_calculation_flag\n          order by\n            begin_date\n          )\n          select\n            s.session_id\n            ,s.final_calculation_flag\n            ,s.begin_date as tdate\n            ,p.full_name as pname\n            ,p.trader_code as pcode\n            ,t.trader_code as tcode\n            ,t.region_code as region_code\n            ,substr(t.zsp_links, 1, 8) as zsp_code\n            ,d.p_nc_unreg_avg * 1000\tas P_nc_unreg_avg\n            ,d.p_vc_unreg_avg * 1000\tas P_vc_unreg_avg\n          from\n            table_period tp\n            join rep_nov.frs_pr_session s \n              on TP.session_id = s.session_id and s.begin_date = tp.begin_date\n            join rep_nov.app_session_list c \n              on TP.session_id = c.session_id\n            join rep_nov.session_gtp_dim d \n              on TP.session_id = d.session_id\n            left join rep_nov.session_gtp_dim sgd_1 \n              on c.prev_session_id = sgd_1.session_id \n              and d.gtp_id = sgd_1.gtp_id,\t\t\t\t  \n            rep_nov.trader t,\n            rep_nov.trader p\n          where\n            t.real_trader_id = d.gtp_id\n            and t.parent_object_id = p.real_trader_id\n            and t.trader_type = 100\n            and s.begin_date between t.begin_date and t.end_date\n            and s.begin_date between p.begin_date and p.end_date\n            and s.final_calculation_flag = 1\n          order by\n            tdate, tcode ,final_calculation_flag\n          ) t1\n          left join \n            rep_nov.crm_region reg\n          on \n            t1.region_code = reg.region_code\")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\n# retrieving data from the database\nretrieved_svnc_fact <- extractSVNC_FACT(jdbcConnectionSVNC, begin_date, end_date)\nretrieved_svnc_fact <- retrieved_svnc_fact[, c(\"TDATE\", \"PNAME\", \"PCODE\", \"TCODE\",\n                        \"REGION_CODE\", \"REGION_NAME\", \"ZSP_CODE\", \"P_VC_UNREG_AVG\", \"P_NC_UNREG_AVG\")]\nretrieved_svnc_fact$TDATE <- as.Date(retrieved_svnc_fact$TDATE)\n#last_fact_date <- as.character(cut(as.Date(cut(Sys.Date(), \"month\")) - 1, \"month\"))\n#DPG_list <- unique(filterActuals(retrieved_svnc_fact, \"TDATE\", \"TCODE\", last_fact_date)$TCODE)\n#retrieved_svnc_fact <- retrieved_svnc_fact[which(retrieved_svnc_fact$TCODE %in% DPG_list), ]\n# SAVE FACT DATA\nwrite.csv(retrieved_svnc_fact, \"C:/!zemskov/svnc_forecast/data_sources/fact_dec_nee_2016.csv\")\n\n# saving accumulated data\n#save(retrieved_svnc_fact, file = \"SVNC_FACT_N_EE.RData\")\ndbDisconnect(jdbcConnectionSVNC)\n\n#### LOADING PIKES AND VOLUMES ####\n\n# PIKES\n\n# creating connection to MFORMRED\njdbcConnectionMFORM <- dbConnect(jdbcDriver, \"jdbc:oracle:thin:@//lp-a6o11-42.rosenergo.com:1521/mformred.rosenergo.com\", \"zemskov\", \"Lun2i2q\")\njdbcConnectionMINIWH <- dbConnect(jdbcDriver, \"jdbc:oracle:thin:@//lp-a6o11-161.rosenergo.com:1521/miniwh.rosenergo.com\", \"zemskov\", \"Lun2i2q\")\n\n# loading fact pikes values\nextractPikesFact <- function(connection, begin_date, end_date, ...) {\n  message(\"extracting pikes ...\")\n  message(\"starting query ...\")\n  message(\"from \", begin_date, \" to \", end_date)\n  query <- \n    paste(\"\n            select \n              m.target_month as TDATE, \n              t.trader_code as TCODE,  \n              t.price_zone_code as PZ, \n              m.p_fact as PIKE_FACT \n            from \n              mform.MFORM_gtp_m_arch m,\n              mform.trader t\n            where \n              m.end_ver = 999999999999999 and \n              m.calc_type = 2 \n              and m.target_month between to_date('\",begin_date,\"','yyyy-mm-dd') \n                and to_date('\",end_date,\"','yyyy-mm-dd')\n              and m.target_month between t.begin_date and t.end_date\n              and m.gtp_id = t.real_trader_id\n              and t.dpg_type = 1\n            order by \n              m.target_month,  \n              t.trader_code\")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\n\n# evaluating pike values for the current month\nevaluatePikes <-  function(connection, current_month, ...) {\n  message(\"evaluating pikes ...\")\n  message(\"starting query ...\")\n  message(\"Evaluating pikes for the current month... \")\n  query <- \n    paste(\"\n          with dates_table as\n\t\t\t\t  (\n            select\n              trunc(TO_DATE ('\",end_date,\"', 'yyyy-mm-dd'),'month') as Begin_Date,\n              to_date ('\",end_date,\"', 'yyyy-mm-dd') as End_Date\n            from\n              dual\n          ),\n          pikes as \n          (\n          select\n            ts.target_date  as tdate\n            ,d.hour as hour\n            ,t.trader_code as tcode\n            ,t.price_zone_code as pz\n            ,t.region_code as rcode\n            ,d.volume / 1000 as pike\n            ,sum(nvl(d.volume,0)/1000) over(partition by ts.target_date,\n              t.region_code, d.hour) as region_pike\n          from\n            dates_table dt, \n            tst_wh.trade_session ts,\n            tst_wh.wh_deal_data_hour d,\n            tst_wh.wh_trader t\n          where\n          ts.target_date between dt.begin_Date and dt.End_Date\n          and tst_wh.is_workday(ts.target_date) not in (0,2)\n          and ts.trade_session_id = d.trade_session_id\n          and ts.trade_session_id = t.trade_session_id\n          and d.dpg_code = t.trader_code\n          and d.deal_type = 3\n          and d.direction = 1\n          and d.volume > 0\n          and nvl(t.is_fsk,0) = 0\n          and nvl(t.is_unpriced_zone,0) = 0\n          and nvl(t.is_gaes,0) = 0\n          and (t.price_zone_code = 1 and d.hour between 7 and 22 \n                or t.price_zone_code=2 and d.hour between 3 and 19)\n          ),\n          region_pikes as\n          (\n            select\n              tdate,\n              max(hour) as hour,\n              rcode,\n              region_pike\n            from\n            (\n              select\n              tdate,\n              hour,\n              rcode,\n              region_pike,\n              max(region_pike) over (partition by rcode, tdate) as max_region_pike\n              from\n                pikes  \n              group by\n                tdate, \n                hour, \n                rcode, \n                region_pike \n            )\n            where\n              region_pike = max_region_pike \n            group by\n              tdate, \n              rcode, \n              region_pike\n            order by\n              rcode, \n              tdate, \n              hour\n            )\n          select\n            trunc(tdate, 'month') as tdate,\n            tcode as tcode,\n            pz,\n            round(avg(pike),3) as PIKE_FACT\n          from(\n            select\n            t.tdate,\n            t.tcode,\n            t.pz,\n            t.rcode as ,\n            t.pike,\n            t.pike / p.region_pike as k_R_i_t\n          from\n            pikes t,\n            region_pikes p\n          where\n            t.tdate = p.tdate\n            and t.rcode = p.rcode\n            and t.hour = p.hour\n            and substr(t.tcode,1,1) <> 'F'\n          ) \n          group by\n            trunc(tdate,'month'), \n            tcode,\n            pz,\n            rcode\n          order by\n            tcode, \n            tdate\")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\n\n# executing queries\nretrieved_pikes <- extractPikesFact(jdbcConnectionMFORM, begin_date, end_date)\nretrieved_pikes$TDATE <- as.Date(retrieved_pikes$TDATE)\nevaluated_pikes <- evaluatePikes(jdbcConnectionMINIWH, end_date)\nevaluated_pikes$TDATE <- as.Date(evaluated_pikes$TDATE)\n\n# Union of the fact and evaluated pikes\npikes_new <- rbind(retrieved_pikes, evaluated_pikes)\npikes <- rbind(pikes, pikes_new)\n\n# saving accumulated data\nsave(pikes, file = \"PIKES_FACT.RData\")\n\n#rm(evaluated_pikes)\n#rm(retrieved_pikes)\n\n#joining pikes to svnc\nsvnc_with_pikes <- merge(retrieved_svnc_fact, retrieved_pikes, \n                         by = c(\"TCODE\", \"TDATE\"), all.x = TRUE, sort = TRUE)\nrm(retrieved_pikes)\n#save(svnc_with_pikes, file = \"DATA_FOR_NN.RData\")\n\n# VOLUMES\nextractVolumesFact <- function(connection, begin_date, end_date, ...) {\n  message(\"extracting volumes ...\")\n  message(\"starting query ...\")\n  message(\"from \", begin_date, \" to \", end_date)\n  query <- \n    paste(\"\n          with TRADE_SESSIONS as\n        \t\t(select \n              trade_session_id \n            from \n              ODS_002.trade_session\n            where \n              target_date between to_date('\",begin_date,\"','yyyy-mm-dd')\n              and to_date('\",end_date,\"','yyyy-mm-dd')\n              and valid_to_dttm > sysdate()\n            )\n          select   \n            trunc(ts.target_date, 'month')  as TDATE\n            ,t.trader_code as TCODE\n            ,nvl(sum(d.volume)/1000, 0) as VOLUME\n          from \n            ODS_002.trade_session ts,\n            ODS_002.wh_deal_data_hour d,\n            ODS_002.wh_trader t                                                \n          where\n            ts.trade_session_id = d.trade_session_id\n            and ts.trade_session_id = t.trade_session_id\n            and d.dpg_code = t.trader_code\n            and d.deal_type = 3\n            and d.direction = 1\n            and d.volume > 0\n            and (nvl(t.fed_station::NUMERIC,0) = 0 \n              or t.is_guarantee_supply_co = 1)\n            and ts.target_date between to_date('\",begin_date,\"','yyyy-mm-dd')\n            and to_date('\",end_date,\"','yyyy-mm-dd') \n            and nvl(t.is_fsk::NUMERIC,0) = 0\n            and nvl(t.is_unpriced_zone::NUMERIC,0) = 0\n            and nvl(t.region_code::NUMERIC, 0) > 0\n            and nvl(t.oes::NUMERIC,0) > 0\n            and ts.valid_to_dttm > sysdate()\n\t\t\t\t    and d.valid_to_dttm > sysdate()\n            and t.valid_to_dttm > sysdate()\n            and ts.trade_session_id in (select * from TRADE_SESSIONS)\n            and d.trade_session_id in (select * from TRADE_SESSIONS)\n            and t.trade_session_id in (select * from TRADE_SESSIONS)\n          group by\n             t.price_zone_code\n            ,t.trader_code\n            ,t.region_code\n            ,t.is_guarantee_supply_co\n            ,trunc(ts.target_date , 'month')\n          order by\n            tcode\n            ,region_code\n            ,tdate\")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\n\n# executing query\nretrieved_volumes_new <- extractVolumesFact(verticaConnection, begin_date, end_date)\nretrieved_volumes_new$TDATE <- as.Date(retrieved_volumes_new$TDATE)\n\n# Union of the newly retrieved and historical data\nretrieved_volumes <- rbind(retrieved_volumes, retrieved_volumes_new) \nretrieved_volumes <- retrieved_volumes[order(retrieved_volumes$TCODE, retrieved_volumes$TDATE), ]\n\n# saving accumulated data\n#retrieved_volumes$TDATE <- as.Date(retrieved_volumes$TDATE)\nsave(retrieved_volumes, file = \"VOLUMES_FACT.RData\")\nsvnc_pikes_volumes <- merge(svnc_with_pikes, retrieved_volumes_new, \n                            by = c(\"TDATE\", \"TCODE\"), all.x = TRUE, sort = TRUE)\nrm(svnc_with_pikes)\n\n#rm(retrieved_volumes)\n#save(svnc_pikes_volumes, file = \"svnc_pikes_volumes.RData\")\n\n#### KOM Prices by price zones (after 01.01.2016) ####\nextractKOMPricesPZ <- function(connection, begin_year, end_year, ...) {\n  message(\"extracting KOM prices ...\")\n  message(\"starting query ...\")\n  message(\"from \", begin_year, \" to \", end_year)\n  query <- \n    paste(\"\n          select \n            target_date as TDATE,\n            price_zone_code as PZ,\n            price_kom\n          from \n  \t\t\t\t  mform.result_com_price_zone \n          where\n            target_date between to_date('\",begin_year,\"','yyyy-mm-dd') \n            and to_date('\",end_year,\"','yyyy-mm-dd')\n            and end_ver = 999999999999999\n          \")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\nretrieved_KOM_PZ <- extractKOMPricesPZ(jdbcConnectionMFORM, begin_year, end_year)\nretrieved_KOM_PZ$TDATE <- as.Date(retrieved_KOM_PZ$TDATE)\nretrieved_KOM_PZ$YEAR <- format(retrieved_KOM_PZ$TDATE, \"%Y\")\nretrieved_KOM_PZ <- retrieved_KOM_PZ[, -1]\nsave(retrieved_KOM_PZ, file = \"KOM_PZ_PRICES.RData\")\n\n#### KOM Prices by ZSP (before 01.01.2016) ####\nextractKOMPricesZSP <- function(connection, begin_date, end_date, ...) {\n  message(\"starting query ...\")\n  message(\"from \", begin_date, \" to \", end_date)\n  query <- \n    paste(\"\n          select \n            zsp_code,\n            target_date as tdate,\n            price_kom as zsp_price_kom\n          from \n            mform.kom_result_zsp_dfr\n          where\n            end_ver = 999999999999999\n            and target_date between to_date('\",begin_date,\"', 'yyyy-mm-dd') and  \n            to_date('\",end_date,\"', 'yyyy-mm-dd')\n            order by\n            zsp_code, tdate\n          \")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\nretrieved_KOM_ZSP <- extractKOMPricesZSP(jdbcConnectionMFORM, history_begin_date, forecast_date)\nretrieved_KOM_ZSP$TDATE <- as.Date(retrieved_KOM_ZSP$TDATE)\nretrieved_KOM_ZSP$YEAR <- format(retrieved_KOM_ZSP$TDATE, \"%Y\")\nretrieved_KOM_ZSP <- retrieved_KOM_ZSP[, -2]\n\n#### Joining KOM Prices ####\nsvnc_pikes_volumes$YEAR <- format(svnc_pikes_volumes$TDATE, \"%Y\")\nsvnc_p_v_kom_new <- merge(svnc_pikes_volumes, retrieved_KOM_PZ, \n                      by = c(\"YEAR\", \"PZ\"), all.x = TRUE, sort = FALSE)\nsvnc_p_v_kom_new <- merge(svnc_p_v_kom_new, retrieved_KOM_ZSP, by = c(\"YEAR\", \"ZSP_CODE\"), \n                      all.x = TRUE, sort = FALSE)\nsvnc_p_v_kom_new$KOM_PRICE <- ifelse(is.na(svnc_p_v_kom_new$PRICE_KOM), svnc_p_v_kom_new$ZSP_PRICE_KOM, \n                       svnc_p_v_kom_new$PRICE_KOM)\nsvnc_p_v_kom_new <- svnc_p_v_kom_new[, -c(14, 15)]\nsvnc_p_v_kom <- rbind(svnc_p_v_kom, svnc_p_v_kom_new)\nsvnc_p_v_kom <- svnc_p_v_kom[order(svnc_p_v_kom$TDATE, svnc_p_v_kom$TCODE), ]\nsave(svnc_p_v_kom, file = \"C:/!zemskov/svnc_forecast/data_sources/SVNC_P_V_KOM_FACT.RData\")\n\n#### Consume Price Index (CPI) ####\nlibrary(xlsx)\n#CPI <- read.xlsx(\"CPI.xlsx\", sheetName = \"CPI\", header = TRUE)\ndataUrl <- paste(\"http://quote.rbc.ru/cgi-bin/macro/ind_export.cgi?bdate=\",\n                 form_begin,\"&edate=\",form_end,\"&ind_id=174&c_id=1\", sep = \"\")\ncpi_data <- read.csv(dataUrl, sep = \";\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### TRY {AUTO-LOADER WITH AUTO-CLICKING} ####\n\n\n# reading CPI data from quotes.rbc.ru\nrequire(RCurl)\nrequire(rvest)\nrequire(httr)\n\n# Proxy was set up with CNTLMlocalhost proxy\n# CNTLM config file is in C:\\Program Files\\CNTLM directory\n# commands are: \"net start(stop) cntlm\"\n# Port, used to listen to - 8080\n#opts <- list(\n#  proxy         = \"http://localhost\", \n#  proxyusername = \"i.zemskov\", \n#  proxypassword = \"GrandPik9\", \n#  proxyport     = 8080\n#)\n#cpi_url <- getURL(\"http://quote.rbc.ru/macro/indicator/1/174.shtml\", .opts = opts)\n#cpi_table <- readHTMLTable(cpi_url, as.data.frame = TRUE)[[5]]\n\n# Function, that submits dates to the html-form and clicks the export \n# setting the proxy configuration\nset_config(use_proxy(url=\"http://localhost\", 8080, \"i.zemskov\", \"GrandPik9\"))\n# creating simulation of the session in an html browser\nsession <- html_session(\"http://quote.rbc.ru/macro/indicator/1/174.shtml\")\n\n# form with the date-picker\ndate_form <- html_form(session)[[3]]  \n\n# dates for the date-picker control\nform_begin <- \"01.01.2011\"            # maybe automate later...\nform_end <- \"01.01.2017\"              # maybe automate later...\n\n# setting input values to the form\n# bdate and edate - names from the html code of the URL\ndate_form <- set_values(date_form, bdate = form_begin, edate = form_end)\n\n# Appends element of a list to another without changing variable type of x\n# build_url function uses the httr package and requires a variable of the url class\nappendList <- function (x, val)\n{\n  stopifnot(is.list(x), is.list(val))\n  xnames <- names(x)\n  for (v in names(val)) {\n    x[[v]] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]]))\n      appendList(x[[v]], val[[v]])\n    else c(x[[v]], val[[v]])\n  }\n  x\n}\n\n# Simulating submit_form for GET requests\nsubmit_geturl <- function (session, form)\n{\n  query <- rvest:::submit_request(form)\n  query$method <- NULL\n  query$encode <- NULL\n  query$url <- NULL\n  names(query) <- \"query\"\n  \n  relativeurl <- XML::getRelativeURL(form$url, session$url)\n  basepath <- parse_url(relativeurl)\n  \n  fullpath <- appendList(basepath,query)\n  fullpath <- build_url(fullpath)\n  fullpath\n}\n\n# Submit form and get new url\nsession1 <- submit_geturl(session, date_form)\n\n\n\ncpi_table<-read_html(session1, encoding = \"windows-1251\")%>%\n  html_table(fill=TRUE)%>%\n  .[[11]] # number of the table node in html document on quotes.rbc.ru\n\n# Get the data\nsession2 <- follow_link(session1, css = \"#more_9 li:nth-child(3) a\")\nreviews <- session2 %>% html_nodes(\".description\") %>% html_text()\nreviews\n\n\nload_session <- html_session(dataUrl)\n\n",
    "created" : 1472460559879.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "58|44|108|0|\n119|69|195|0|\n220|69|248|0|\n251|60|363|0|\n388|71|446|0|\n467|71|487|0|\n495|72|516|0|\n",
    "hash" : "2708253281",
    "id" : "F50B1E58",
    "lastKnownWriteTime" : 1488359662,
    "path" : "C:/!zemskov/svnc_forecast/load_svnc_n_fact_from_db.R",
    "project_path" : "load_svnc_n_fact_from_db.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}