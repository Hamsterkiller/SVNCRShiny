{
    "contents" : "# cleaning workspace\nrm(list = ls())\n# loading accumulated data\n\n# setwd(\"c:/!zemskov/svnc_forecast/shiny_app\")\nload(\"data_sources/SVNC_P_V_KOM_FACT.RData\")\nload(\"data_sources/PIKES_FACT.RData\")\nload(\"data_sources/VOLUMES_FACT.RData\")\nmax_svnc_fact_date <- max(svnc_p_v_kom$TDATE)\nmax_pikes_fact_date <- max(pikes$TDATE)\nmax_volumes_fact_date <- max(retrieved_volumes$TDATE)\n#end_date <- as.Date(cut(Sys.Date(), \"month\"))\n#begin_date <- as.Date(cut(max_fact_date + 31, \"month\"))\n#kom_date_begin <- as.Date(cut(begin_date, \"year\"))\n#kom_date_end <- as.Date(cut(end_date + 31, \"year\"))\n\n# begining of the history of analytics date\nhistory_begin_date <- \"2011-01-01\"\n# starting date of the loading period\nbegin_date <- as.Date(cut(max(svnc_p_v_kom$TDATE) + 25, \"month\"))\n# ending date of the loading period\nend_date <- Sys.Date()\nforecast_date <- as.Date(cut(end_date + 20, \"month\"))\nbegin_year <- cut(max(svnc_p_v_kom$TDATE) + 25, \"year\")\nend_year <- cut(forecast_date, \"year\")\n\n\n# Preloading data\n# Loading libraries\nlibrary(RJDBC)\nlibrary(rJava)\n\n\n\n\n# RIO\n# extract DGPC_GP-info\nextractDPGGP <- function(connection, date) {\n  message(\"extracting DPG_GP info ...\")\n  message(\"starting query ...\")\n  message(\"for \", date)\n  query <- \n    paste(\"\n          select\n          t1.pcode,\n          t1.pname,\n          t1.tcode,\n          t1.pz,\n          t1.region_code,\n          t2.region_name\n          from\n          (select\n          p.trader_code as pcode,\n          p.short_name as pname,\n          t.trader_code as tcode,\n          t.price_zone_code as pz,\n          t.region_code \n          from\n          crmdb.trader t,\n          crmdb.trader p\n          where\n          t.parent_object_id = p.trader_id\n          and to_date('\",date,\"','yyyy.mm.dd') between t.begin_date and t.end_date \n          and t.trader_type = 100\n          and nvl(t.is_fsk,0) = 0\n          and t.is_guarantee_supply_co = 1\n          and t.is_unpriced_zone ^= 1\n          and nvl(t.price_zone_code, 0) in (1,2)\n          and (t.is_spot_trader = 1\n          or t.is_forem_trader = 1)\n          order by\n          pcode, region_code) t1\n          left join\n          (select\n          region_code,\n          region_name\n          from\n          crmdb.region) t2\n          on\n          t1.region_code = t2.region_code\n          order by\n          pcode,\n          region_code\n          \")\n  cursor <- dbGetQuery(connection, query)\n  message(\"query was executed successfuly\")\n  return (cursor)\n}\n\ndpg_gp_info <- tryCatch (\n  {\n    \n    # Set JAVA_HOME, set max. memory, and load rJava library\n    Sys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_65/bin')\n    #options(java.parameters=\"-Xmx2g\")\n    \n    # Checking Java version\n    .jinit()\n    print(.jcall(\"java/lang/System\", \"S\", \"getProperty\", \"java.version\"))\n    \n    # Create connection driver and open connection\n    ## ORACLE:\n    jdbcDriver <- JDBC(driverClass=\"oracle.jdbc.OracleDriver\", \n                       classPath=\"shiny_app/libs/ojdbc7.jar\")\n    \n    jdbcConnectionRIO <- dbConnect(jdbcDriver, \n        \"jdbc:oracle:thin:@//x240-11.rosenergo.com:1521/frs9i2.rosenergo.com\", \n        \"zemskov\", \"Lun2i2q\")\n    dpg_gp_info <- extractDPGGP(jdbcConnectionRIO, forecast_date)\n    save(file = 'DPG_GP_INFO.RData', dpg_gp_info)\n    dbDisconnect(jdbcConnectionRIO)\n    return (dpg_gp_info)\n  }, error = function(cond) {\n    message(\"Connection failed. Loading in offline mode...\")\n    load(file = 'data_sources/DPG_GP_INFO.RData')\n    message(\"gp info loaded...\")\n    return (dpg_gp_info)\n  } \n)\n\n# unique pairs of pcode-region\ngp_region <- unique(dpg_gp_info[, c('PCODE', 'REGION_CODE')])\nsave(file = 'data_sources/GP_REGION.RData', gp_region)\n\nmessage('++++++++++++++++++++++++++')\n\n# SVNC, volumes and pikes\nif (as.numeric(end_date - max_svnc_fact_date) > 75) {\n  \n  # extract data with fact prices by dpg\n  extractSVNC_FACT <- function(connection, begin_date, end_date, ...) {\n    message(\"extracting SVNC ...\")\n    message(\"starting query ...\")\n    message(\"from \", begin_date, \" to \", end_date)\n    query <- \n      paste(\"\n            select \n            t1.*, \n            reg.region_name\n            from(\n            with table_period as\n            (\n            select s.begin_date, max(s.session_id) as session_id, s.final_calculation_flag\n            from \n            (\n            select \n            begin_date, \n            max(final_calculation_flag) as final_calculation_flag\n            from \n            rep_nov.frs_pr_session\n            where\n            begin_date between to_date('\",begin_date,\"', 'yyyy-mm-dd') \n            and to_date('\",end_date,\"','yyyy-mm-dd')\n            group by \n            begin_date\n            ) ts,\n            rep_nov.frs_pr_session s\n            where \n            ts.begin_date = s.begin_date \n            and ts.final_calculation_flag = s.final_calculation_flag\n            group by\n            s.begin_date, s.final_calculation_flag\n            order by\n            begin_date\n            )\n            select\n            s.session_id\n            ,s.final_calculation_flag\n            ,s.begin_date as tdate\n            ,p.full_name as pname\n            ,p.trader_code as pcode\n            ,t.trader_code as tcode\n            ,t.region_code as region_code\n            ,substr(t.zsp_links, 1, 8) as zsp_code\n            ,d.p_nc_unreg_avg * 1000\tas P_nc_unreg_avg\n            ,d.p_vc_unreg_avg * 1000\tas P_vc_unreg_avg\n            from\n            table_period tp\n            join rep_nov.frs_pr_session s \n            on TP.session_id = s.session_id and s.begin_date = tp.begin_date\n            join rep_nov.app_session_list c \n            on TP.session_id = c.session_id\n            join rep_nov.session_gtp_dim d \n            on TP.session_id = d.session_id\n            left join rep_nov.session_gtp_dim sgd_1 \n            on c.prev_session_id = sgd_1.session_id \n            and d.gtp_id = sgd_1.gtp_id,\t\t\t\t  \n            rep_nov.trader t,\n            rep_nov.trader p\n            where\n            t.real_trader_id = d.gtp_id\n            and t.parent_object_id = p.real_trader_id\n            and t.trader_type = 100\n            and s.begin_date between t.begin_date and t.end_date\n            and s.begin_date between p.begin_date and p.end_date\n            and s.final_calculation_flag = 1\n            order by\n            tdate, tcode ,final_calculation_flag\n            ) t1\n            left join \n            rep_nov.crm_region reg\n            on \n            t1.region_code = reg.region_code\")\n    cursor <- dbGetQuery(connection, query)\n    message(\"query was executed successfuly\")\n    return (cursor)\n  }\n  \n  \n  # loading data\n  svnc_data <- tryCatch ({\n    jdbcConnectionSVNC <- dbConnect(jdbcDriver, \n          \"jdbc:oracle:thin:@//hx5-06.rosenergo.com:1521/svncgrey.rosenergo.com\", \n          \"zemskov\", \"Lun2i2q\")\n    \n    print(\"fetching new svnc data ...\")\n    \n    # retrieving data from the database\n    retrieved_svnc_fact <- extractSVNC_FACT(jdbcConnectionSVNC, begin_date, end_date)\n    retrieved_svnc_fact <- retrieved_svnc_fact[, c(\"TDATE\", \"PNAME\", \"PCODE\", \"TCODE\",\n                                                   \"REGION_CODE\", \"REGION_NAME\", \"ZSP_CODE\", \"P_VC_UNREG_AVG\", \"P_NC_UNREG_AVG\")]\n    retrieved_svnc_fact$TDATE <- as.Date(retrieved_svnc_fact$TDATE)\n    # closing connection to svncgrey database\n    dbDisconnect(jdbcConnectionSVNC)\n    \n    # creating connection to MFORMRED\n    jdbcConnectionMFORM <- dbConnect(jdbcDriver, \"jdbc:oracle:thin:@//lp-a6o11-42.rosenergo.com:1521/mformred.rosenergo.com\", \"zemskov\", \"Lun2i2q\")\n    jdbcConnectionMINIWH <- dbConnect(jdbcDriver, \"jdbc:oracle:thin:@//lp-a6o11-161.rosenergo.com:1521/miniwh.rosenergo.com\", \"zemskov\", \"Lun2i2q\")\n    \n    # PIKES\n    if (as.numeric(end_date - max_pikes_fact_date) > 45) {\n      \n      # deleting evaluated and 'not full month data'\n      pikes <- pikes[pikes$TDATE < as.Date(begin_date), ]\n      \n      print(\"fetching new pikes data ...\")\n      # loading fact pikes values\n      extractPikesFact <- function(connection, begin_date, end_date, ...) {\n        message(\"extracting pikes ...\")\n        message(\"starting query ...\")\n        message(\"from \", begin_date, \" to \", end_date)\n        query <- \n          paste(\"\n                select \n                m.target_month as TDATE, \n                t.trader_code as TCODE,  \n                t.price_zone_code as PZ, \n                m.p_fact as PIKE_FACT \n                from \n                mform.MFORM_gtp_m_arch m,\n                mform.trader t\n                where \n                m.end_ver = 999999999999999 and \n                m.calc_type = 2 \n                and m.target_month between to_date('\",begin_date,\"','yyyy-mm-dd') \n                and to_date('\",end_date,\"','yyyy-mm-dd')\n                and m.target_month between t.begin_date and t.end_date\n                and m.gtp_id = t.real_trader_id\n                and t.dpg_type = 1\n                order by \n                m.target_month,  \n                t.trader_code\")\n        cursor <- dbGetQuery(connection, query)\n        message(\"query was executed successfuly\")\n        return (cursor)\n      }\n      # evaluating pike values for the current month\n      evaluatePikes <-  function(connection, current_month, ...) {\n        message(\"evaluating pikes ...\")\n        message(\"starting query ...\")\n        message(paste(\"Evaluating pikes for the\", cut(end_date, \"month\")))\n        query <- \n          paste(\"\n                with dates_table as\n                (\n                select\n                trunc(TO_DATE ('\",end_date,\"', 'yyyy-mm-dd'),'month') as Begin_Date,\n                to_date ('\",end_date,\"', 'yyyy-mm-dd') as End_Date\n                from\n                dual\n                ),\n                pikes as \n                (\n                select\n                ts.target_date  as tdate\n                ,d.hour as hour\n                ,t.trader_code as tcode\n                ,t.price_zone_code as pz\n                ,t.region_code as rcode\n                ,d.volume / 1000 as pike\n                ,sum(nvl(d.volume,0)/1000) over(partition by ts.target_date,\n                t.region_code, d.hour) as region_pike\n                from\n                dates_table dt, \n                tst_wh.trade_session ts,\n                tst_wh.wh_deal_data_hour d,\n                tst_wh.wh_trader t\n                where\n                ts.target_date between dt.begin_Date and dt.End_Date\n                and tst_wh.is_workday(ts.target_date) not in (0,2)\n                and ts.trade_session_id = d.trade_session_id\n                and ts.trade_session_id = t.trade_session_id\n                and d.dpg_code = t.trader_code\n                and d.deal_type = 3\n                and d.direction = 1\n                and d.volume > 0\n                and nvl(t.is_fsk,0) = 0\n                and nvl(t.is_unpriced_zone,0) = 0\n                and nvl(t.is_gaes,0) = 0\n                and (t.price_zone_code = 1 and d.hour between 7 and 22 \n                or t.price_zone_code=2 and d.hour between 3 and 19)\n                ),\n                region_pikes as\n                (\n                select\n                tdate,\n                max(hour) as hour,\n                rcode,\n                region_pike\n                from\n                (\n                select\n                tdate,\n                hour,\n                rcode,\n                region_pike,\n                max(region_pike) over (partition by rcode, tdate) as max_region_pike\n                from\n                pikes  \n                group by\n                tdate, \n                hour, \n                rcode, \n                region_pike \n                )\n                where\n                region_pike = max_region_pike \n                group by\n                tdate, \n                rcode, \n                region_pike\n                order by\n                rcode, \n                tdate, \n                hour\n                )\n                select\n                trunc(tdate, 'month') as tdate,\n                tcode as tcode,\n                pz,\n                round(avg(pike),3) as PIKE_FACT\n                from(\n                select\n                t.tdate,\n                t.tcode,\n                t.pz,\n                t.rcode as ,\n                t.pike,\n                t.pike / p.region_pike as k_R_i_t\n                from\n                pikes t,\n                region_pikes p\n                where\n                t.tdate = p.tdate\n                and t.rcode = p.rcode\n                and t.hour = p.hour\n                and substr(t.tcode,1,1) <> 'F'\n                ) \n                group by\n                trunc(tdate,'month'), \n                tcode,\n                pz,\n                rcode\n                order by\n                tcode, \n                tdate\")\n        cursor <- dbGetQuery(connection, query)\n        message(\"query was executed successfuly\")\n        return (cursor)\n      }\n      # executing queries\n      retrieved_pikes <- extractPikesFact(jdbcConnectionMFORM, begin_date, end_date)\n      retrieved_pikes$TDATE <- as.Date(retrieved_pikes$TDATE)\n      evaluated_pikes <- evaluatePikes(jdbcConnectionMINIWH, end_date)\n      evaluated_pikes$TDATE <- as.Date(evaluated_pikes$TDATE)\n      # Union of the fact and evaluated pikes\n      pikes_new <- rbind(retrieved_pikes, evaluated_pikes)\n      # Leaving only actual DPGs\n      #pikes <- pikes[which(pikes$TCODE %in% DPG_list), ]\n      pikes <- rbind(pikes, pikes_new)\n      # saving accumulated data\n      save(pikes, file = \"data_sources/PIKES_FACT.RData\")\n      svnc_with_pikes <- merge(retrieved_svnc_fact, retrieved_pikes, \n                               by = c(\"TCODE\", \"TDATE\"), all.x = TRUE, sort = TRUE)\n    } else {\n      print(\"using preloaded pikes data...\")\n      svnc_with_pikes <- merge(retrieved_svnc_fact, pikes, \n                               by = c(\"TCODE\", \"TDATE\"), all.x = TRUE, sort = TRUE)\n    }\n    # closing connection to mformred database\n    dbDisconnect(jdbcConnectionMFORM)\n    \n    # VOLUMES\n    if (as.numeric(end_date - max_volumes_fact_date) > 45) {\n      \n      # deleting evaluated and 'not full month data'\n      retrieved_volumes <- retrieved_volumes[retrieved_volumes$TDATE < as.Date(begin_date), ]\n      \n      print(\"fetching new volumes data ...\")\n      extractVolumesFact <- function(connection, begin_date, end_date, ...) {\n        message(\"extracting volumes ...\")\n        message(\"starting query ...\")\n        message(\"from \", begin_date, \" to \", end_date)\n        query <- \n          paste(\"\n                with TRADE_SESSIONS as\n                (select \n                trade_session_id \n                from \n                ODS_002.trade_session\n                where \n                target_date between to_date('\",begin_date,\"','yyyy-mm-dd')\n                and to_date('\",end_date,\"','yyyy-mm-dd')\n                and valid_to_dttm > sysdate()\n                )\n                select   \n                trunc(ts.target_date, 'month')  as TDATE\n                ,t.trader_code as TCODE\n                ,nvl(sum(d.volume)/1000, 0) as VOLUME\n                from \n                ODS_002.trade_session ts,\n                ODS_002.wh_deal_data_hour d,\n                ODS_002.wh_trader t                                                \n                where\n                ts.trade_session_id = d.trade_session_id\n                and ts.trade_session_id = t.trade_session_id\n                and d.dpg_code = t.trader_code\n                and d.deal_type = 3\n                and d.direction = 1\n                and d.volume > 0\n                and (nvl(t.fed_station::NUMERIC,0) = 0 \n                or t.is_guarantee_supply_co = 1)\n                and ts.target_date between to_date('\",begin_date,\"','yyyy-mm-dd')\n                and to_date('\",end_date,\"','yyyy-mm-dd') \n                and nvl(t.is_fsk::NUMERIC,0) = 0\n                and nvl(t.is_unpriced_zone::NUMERIC,0) = 0\n                and nvl(t.region_code::NUMERIC, 0) > 0\n                and nvl(t.oes::NUMERIC,0) > 0\n                and ts.valid_to_dttm > sysdate()\n                and d.valid_to_dttm > sysdate()\n                and t.valid_to_dttm > sysdate()\n                and ts.trade_session_id in (select * from TRADE_SESSIONS)\n                and d.trade_session_id in (select * from TRADE_SESSIONS)\n                and t.trade_session_id in (select * from TRADE_SESSIONS)\n                group by\n                t.price_zone_code\n                ,t.trader_code\n                ,t.region_code\n                ,t.is_guarantee_supply_co\n                ,trunc(ts.target_date , 'month')\n                order by\n                tcode\n                ,region_code\n                ,tdate\")\n        cursor <- dbGetQuery(connection, query)\n        message(\"query was executed successfuly\")\n        return (cursor)\n      }\n      retrieved_volumes_new <- extractVolumesFact(verticaConnection, \n                                                  begin_date, end_date)\n      # Leaving only actual DPGs\n      #retrieved_volumes <- retrieved_volumes[which(retrieved_volumes$TCODE %in% DPG_list), ]\n      retrieved_volumes_new$TDATE <- as.Date(retrieved_volumes_new$TDATE)\n      print(class(retrieved_volumes_new$TDATE))\n      retrieved_volumes <- rbind(retrieved_volumes, \n                                 retrieved_volumes_new)\n      retrieved_volumes <- retrieved_volumes[order(retrieved_volumes$TCODE, retrieved_volumes$TDATE), ]\n      # saving accumulated data\n      save(retrieved_volumes, file = \"VOLUMES_FACT.RData\")\n      svnc_pikes_volumes <- merge(svnc_with_pikes, retrieved_volumes_new, \n                                  by = c(\"TDATE\", \"TCODE\"), all.x = TRUE, sort = TRUE)\n      rm(svnc_with_pikes)\n    } else {\n      print(\"using preloaded volumes data...\")\n      svnc_pikes_volumes <- merge(svnc_with_pikes, retrieved_volumes, \n                                  by = c(\"TDATE\", \"TCODE\"), all.x = TRUE, sort = TRUE)\n    }\n    # closing connection to miniwh database\n    dbDisconnect(jdbcConnectionMINIWH)\n    \n    #### KOM Prices by price zones (after 01.01.2016) ####\n    extractKOMPricesPZ <- function(connection, begin_year, end_year, ...) {\n      message(\"extracting KOM prices ...\")\n      message(\"starting query ...\")\n      message(\"from \", begin_year, \" to \", end_year)\n      query <- \n        paste(\"\n              select \n              target_date as TDATE,\n              price_zone_code as PZ,\n              price_kom\n              from \n              mform.result_com_price_zone \n              where\n              target_date between to_date('\",begin_year,\"','yyyy-mm-dd') \n              and to_date('\",end_year,\"','yyyy-mm-dd')\n              and end_ver = 999999999999999\n              \")\n      cursor <- dbGetQuery(connection, query)\n      message(\"query was executed successfuly\")\n      return (cursor)\n    }\n    retrieved_KOM_PZ <- extractKOMPricesPZ(jdbcConnectionMFORM, begin_year, end_year)\n    retrieved_KOM_PZ$TDATE <- as.Date(retrieved_KOM_PZ$TDATE)\n    retrieved_KOM_PZ$YEAR <- format(retrieved_KOM_PZ$TDATE, \"%Y\")\n    retrieved_KOM_PZ <- retrieved_KOM_PZ[, -1]\n    \n    #### KOM Prices by ZSsvnc_p_v_komP (before 01.01.2016) ####\n    extractKOMPricesZSP <- function(connection, begin_date, end_date, ...) {\n      message(\"starting query ...\")\n      message(\"from \", begin_date, \" to \", end_date)\n      query <- \n        paste(\"\n              select \n              zsp_code,\n              target_date as tdate,\n              price_kom as zsp_price_kom\n              from \n              mform.kom_result_zsp_dfr\n              where\n              end_ver = 999999999999999\n              and target_date between to_date('\",begin_date,\"', 'yyyy-mm-dd') and  \n              to_date('\",end_date,\"', 'yyyy-mm-dd')\n              order by\n              zsp_code, tdate\n              \")\n    cursor <- dbGetQuery(connection, query)\n    message(\"query was executed successfuly\")\n    return (cursor)\n  }\n    retrieved_KOM_ZSP <- extractKOMPricesZSP(jdbcConnectionMFORM, history_begin_date, forecast_date)\n    retrieved_KOM_ZSP$TDATE <- as.Date(retrieved_KOM_ZSP$TDATE)\n    retrieved_KOM_ZSP$YEAR <- format(retrieved_KOM_ZSP$TDATE, \"%Y\")\n    retrieved_KOM_ZSP <- retrieved_KOM_ZSP[, -2]\n    # closing connection to mformred database\n    dbDisconnect(jdbcConnectionMFORM)\n    \n    # Joining all together\n    svnc_pikes_volumes$YEAR <- format(svnc_pikes_volumes$TDATE, \"%Y\")\n    svnc_p_v_kom_new <- merge(svnc_pikes_volumes, retrieved_KOM_PZ, \n                              by = c(\"YEAR\", \"PZ\"), all.x = TRUE, sort = FALSE)\n    svnc_p_v_kom_new <- merge(svnc_p_v_kom_new, retrieved_KOM_ZSP, by = c(\"YEAR\", \"ZSP_CODE\"), \n                              all.x = TRUE, sort = FALSE)\n    svnc_p_v_kom_new$KOM_PRICE <- ifelse(is.na(svnc_p_v_kom_new$PRICE_KOM), svnc_p_v_kom_new$ZSP_PRICE_KOM, \n                                         svnc_p_v_kom_new$PRICE_KOM)\n    svnc_p_v_kom_new <- svnc_p_v_kom_new[, -c(14, 15)]\n    svnc_p_v_kom <- rbind(svnc_p_v_kom, svnc_p_v_kom_new)\n    svnc_p_v_kom <- svnc_p_v_kom[order(svnc_p_v_kom$TDATE, svnc_p_v_kom$TCODE), ]\n    save(svnc_p_v_kom, file = \"data_sources/SVNC_P_V_KOM_FACT.RData\")\n    svnc_data <- svnc_p_v_kom\n    rm(svnc_p_v_kom)\n    rm(svnc_p_v_kom_new)\n    return (svnc_data)\n  }, error = function(cond) {\n    message(\"Connection failed. Loading in offline mode...\")\n    load(\"data_sources/SVNC_P_V_KOM_FACT.RData\")\n    return (svnc_p_v_kom)\n  })\n} else {\n  print(\"using preloaded svnc data...\")\n  svnc_data <- svnc_p_v_kom\n  rm(svnc_p_v_kom)\n}\n  \n\n\npcodes <- unique(svnc_data$PCODE)\npcodes_fcst <- unique(svnc_data[which(svnc_data$TDATE == max(svnc_data$TDATE)), ]$PCODE)\n\n",
    "created" : 1485763171481.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "37|44|87|0|\n90|3|112|2|\n130|71|206|2|\n237|75|265|6|\n267|66|379|6|\n403|60|482|4|\n491|75|511|4|\n518|76|539|2|\n",
    "hash" : "310444174",
    "id" : "16407E46",
    "lastKnownWriteTime" : 1489568297,
    "path" : "C:/!zemskov/svnc_forecast/shiny_app/global.R",
    "project_path" : "shiny_app/global.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}