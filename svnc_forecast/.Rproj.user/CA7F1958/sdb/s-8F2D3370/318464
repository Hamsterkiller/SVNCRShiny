{
    "contents" : "# FUNCTION that applies other functions to the panaled data (grouped by some variable)\napplyByGroups <- function(t, id_var, group_var, value_var, fun) {\n  \n  # safe copying\n  table <- t\n  table <- table[order(table[ , group_var], table[ , id_var]), ]\n  # main cycle\n  for (i in unique(table[, group_var])) {\n    # partitioning by group_var values\n    one_piece  <- table[which(table[ , group_var] == i), ] \n    result_var_name <- paste(deparse(substitute(fun)), \"results\", sep = \"_\")\n    table[which(table[, group_var] == i), result_var_name] <- as.numeric(fun(one_piece[, value_var]))\n  }\n  \n  #rm(one_piece, one_piece_s, starting_point, one_piece_ts,one_piece_ts_final, randomComponent)\n  return (table)\n}\n\n# Function applies forecasting method to paneled time series with history size \n# more than 21 months\napplyForecastingMethod <- function(df, group.var, date.var, target.var, h, n) {\n  require(xts)\n  require(tseries)\n  predictions <- list()\n  # safe copying\n  tbl <- df[, c(group.var , date.var, target.var)]\n  tbl <- tbl[order(tbl[ , group.var], tbl[ , date.var]), ]\n  for (i in unique(tbl[, group.var])) {\n    # partitioning by group_var values\n    one_piece  <- tbl[which(tbl[ , group.var] == i), c(date.var, target.var)]\n    start_date <- min(one_piece[, date.var])\n    # making a TS object\n    one_piece_ts <- toTimeSeries(one_piece, \"date\", 12, start_date)\n    predictions[i] <- predict_price(one_piece_ts, h, n)\n    print(predictions[i])\n  }\n  return (predictions)\n}\n\n# Function applies forecasting method to paneled time series with history size \n# more than 21 months\nhwforecast_n_step_fwrd <- function(df, group.var, date.var, target.var, h, n) {\n  require(xts)\n  require(tseries)\n  predictions <- list()\n  # safe copying\n  tbl <- df[, c(group.var , date.var, target.var)]\n  tbl <- tbl[order(tbl[ , group.var], tbl[ , date.var]), ]\n  for (i in unique(tbl[, group.var])) {\n    # partitioning by group_var values\n    one_piece  <- tbl[which(tbl[ , group.var] == i), c(date.var, target.var)]\n    if (nrow(one_piece[which(is.na(one_piece[, target.var]) == TRUE), ]) > 0)\n      # imputing missing values\n      one_piece <- imputeMedian(one_piece, target.var)\n    start_date <- min(one_piece[, date.var])\n    # making a TS object\n    one_piece_ts <- toTimeSeries(one_piece, date.var, 12, start_date)\n    # predicting with Holt-Winters algorithm\n    prediction_hw <- predict_price(one_piece_ts, h, n)\n    # predicting with ARIMA\n    prediction_arima <- predict_price_short(one_piece_ts, h, n)\n    prediction <- mean(c(prediction_hw, prediction_arima))\n    if (prediction < 0) prediction <- prediction_arima\n    predictions[i] <- prediction\n    print(predictions[i])\n  }\n  return (predictions)\n}\n\n## dealing with NA's\n## function, that imputing NA's with mean vaues in each group\nimputeMean <- function(impute.var, filter.var, var.levels) {\n  for (v in var.levels) {\n    impute.var[ which(filter.var == v)] <- impute(impute.var[\n      which(filter.var == v)\n      ], fun = mean)\n  }\n  return (impute.var)\n}\n\n## dealing with NA's\n## function, that imputing NA's with median vaues\nimputeMedian <- function(df, impute.var) {\n  data <- df\n  data[which(is.na(data[, impute.var]) == TRUE), impute.var] = \n    median(data[which(is.na(data[, impute.var]) == FALSE), impute.var])\n  return (data)\n}\n\n\n# Function predicts h next values of the indicator and returns n-th prediction\n# Designed to apply Holt-Winters Exp. Smoothing algorithm forr time-series with \n# more than 24 months history length\n# cur_ts - time series\n# h - number of steps to predict fur\n# n - number of the prediction to return\npredict_price <- function(cur_ts, h, n) {\n  tryCatch(\n    {\n      print(\"Building Holt-Winters model...\")\n      current_model <- HoltWinters(cur_ts)\n      return (predict(current_model, n = h)[n])\n    }, error = function(cond) {\n      message(\"Holt-Winters model optimization failed to converge!\")\n      print(\"Starting calculation with default algorithm...\")\n      print(\"Algorithm: prediction = prev_month_cur_year/\n            (prev_month_prev_year*cur_month_prev_year)\")\n      return (last(lag(cur_ts)) / last(lag(cur_ts, 13)) * last(lag(cur_ts, 12)))\n    }\n  )\n}\n\n# Function predicts h next values of the indicator and returns n-th prediction\n# Designed to apply Holt-Winters Exp. Smoothing algorithm forr time-series with \n# less than 24 months history length\n# cur_ts - time series\n# h - number of steps to predict fur\n# n - number of the prediction to return\npredict_price_short <- function(cur_ts, nsteps, n) {\n  require(forecast)\n  tryCatch(\n    {\n      print(\"Building Arima model...\")\n      current_model <- auto.arima(cur_ts)\n      return (forecast(current_model, h = nsteps)$mean[n])\n    }, error = function(cond) {\n      message(\"Arima model optimization failed to converge!\")\n      message(\"MA prediction failed!\")\n      print(\"Calculating simple mean...\")\n      return (mean(cur_ts))\n    }\n  )\n}\n\n\n# creating list of DPGs with the siaze of it's history (in months)\nrangeByHistorySize <- function(dataset, keyFactor) {\n  #creating output df\n  historyRanks <- data.frame(FactorLevel=as.character(), \n                             HistorySize=as.integer())\n  # for each unique value of the factor var do...\n  for (i in levels(keyFactor)) {\n    #historyRow <- data.frame(FactorLevel = i, HistorySize = nrow(dataset[which(dataset$keyFactor == i), ]))\n    historyRanks <- rbind(historyRanks, data.frame(FactorLevel = i, \n                                                   HistorySize = nrow(dataset[which(keyFactor == i), ])))\n  }\n  return (historyRanks[order(-historyRanks$HistorySize), ])\n}\n\n# function: devide random component for each group\n## t - data.frame to be processed\n## group_var - grouping variable of t (must be passed as string in quotes: 'group')\n## date_var - date-variable of t (must be passed as string in quotes: 'date')\n## ts_var - numeric variable (must be passed as string in quotes: 'value')\nseparateRandomTSComponent <- function(t, group_var, date_var, ts_var) {\n  \n  # loading required libraries\n  require(xts)\n  \n  # safe copying\n  dpgtable <- t\n  dpgtable <- dpgtable[order(dpgtable[ , group_var], dpgtable[ , date_var]), ]\n  # main cycle\n  for (i in unique(dpgtable[, group_var])) {\n    # creating TS-object\n    one_piece <- dpgtable[which(dpgtable[ , group_var] == i), ] \n    one_piece_s <- one_piece[ , c(group_var, date_var, ts_var)]\n    print(nrow(one_piece_s))\n    starting_point <- min(one_piece_s[ , date_var])\n    one_piece_ts <- xts(one_piece_s[ , ts_var], order.by=as.Date(one_piece[ , date_var]))\n    one_piece_ts_final <- ts(one_piece_ts, frequency=12, start=starting_point)\n    \n    # separating random component of the ts-variable\n    randomComponent <- decompose(one_piece_ts_final)$random\n    dpgtable[which(dpgtable[ , group_var] == i), 'RandomTSComponent'] <- randomComponent \n  }\n  \n  #rm(one_piece, one_piece_s, starting_point, one_piece_ts,one_piece_ts_final, randomComponent)\n  return (dpgtable)\n}\n\n# Function applies forecasting method to paneled time series with history size \n# less than 21 months\nshortForecast <- function(df, group.var, date.var, target.var, h, n) {\n  require(TTR)\n  require(xts)\n  require(tseries)\n  predictions <- list()\n  # safe copying\n  tbl <- df[, c(group.var , date.var, target.var)]\n  tbl <- tbl[order(tbl[ , group.var], tbl[ , date.var]), ]\n  for (i in unique(tbl[, group.var])) {\n    # partitioning by group_var values\n    one_piece  <- tbl[which(tbl[ , group.var] == i), c(date.var, target.var)]\n    if (nrow(one_piece[which(is.na(one_piece[, target.var]) == TRUE), ]) > 0)\n      one_piece <- imputeMedian(one_piece, target.var)\n    start_date <- min(one_piece[, date.var])\n    # making a TS object\n    one_piece_ts <- toTimeSeries(one_piece, date.var, 1, start_date)\n    predictions[i] <- predict_price_short(one_piece_ts, h, n)\n    print(predictions[i])\n  }\n  return (predictions)\n}\n\n\n# auxillary function for viewing source code of R function\nshowSourceCode <- function(name) {\n  name # this is what you did without having a good enough answer\n  methods(name) # Next step, ask for the method: 'princomp.default'\n  query <- paste(name, '.default', sep = '')\n  getAnywhere(query) # this will show you the code\n}\n\n\n# auxillary function for viewing source code of R function\nshowSourceCode <- function(name) {\n  name # this is what you did without having a good enough answer\n  methods(name) # Next step, ask for the method: 'princomp.default'\n  query <- paste(name, '.default', sep = '')\n  getAnywhere(query) # this will show you the code\n}\n\n# creating time-series object from data.frame object\n# df - source data.frame object\n# date_var - String object representing the name of the Date variable\n# start_date - String object, representing the initial point in time\n## !!! length must be >=24 months\ntoTimeSeries <- function(df, date_var, freq, start_date) {\n  require(xts)\n  as_ts <- xts(df[ , !colnames(df) %in% c(date_var)], order.by = df[ , date_var])\n  result <- ts(as_ts, frequency = freq, start = as.Date(start_date))\n  return (result)\n}\n\n# keeping only those objects which exists in the (n-1) month\nfilterActuals <- function(df, date_var, group_var, cur_date) {\n  actualDPGs <- unique(subset(df, df[, date_var] == as.Date(cur_date), \n                              select = group_var))\n  res = merge(df, actualDPGs, by = group_var)\n  return(res)\n}\n\n\n\n\n\n\n",
    "created" : 1482741178486.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "41|79|67|0|\n",
    "hash" : "3095869048",
    "id" : "318464",
    "lastKnownWriteTime" : 1482742666,
    "path" : "C:/!zemskov/svnc_forecast/packages/tsauxfunc/R/tsauxfunc.R",
    "project_path" : "packages/tsauxfunc/R/tsauxfunc.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}